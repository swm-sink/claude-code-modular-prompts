<!-- XML Structure Optimization Template for Claude Code Performance -->
<!-- This template demonstrates optimized XML patterns for improved performance -->

<!-- Entity Definitions for Repeated Content -->
<!DOCTYPE command [
  <!ENTITY crit_think "patterns/critical-thinking-pattern.md">
  <!ENTITY tdd_pattern "patterns/tdd-cycle-pattern.md">
  <!ENTITY impl_pattern "patterns/implementation-pattern.md">
  <!ENTITY qual_pattern "patterns/quality-validation-pattern.md">
  <!ENTITY rec_pattern "patterns/error-recovery-pattern.md">
]>

<!-- Optimized Command Structure -->
<command purpose="Example optimized command structure" version="3.0.0">
  
  <!-- Delegation with compressed syntax -->
  <deleg target="modules/example/optimized-workflow.md">
    Research ‚Üí Plan ‚Üí Execute ‚Üí Validate ‚Üí Optimize
  </deleg>
  
  <!-- Pattern integration with entity references -->
  <patterns>
    <use from="&crit_think;" type="analysis"/>
    <use from="&tdd_pattern;" type="cycle"/>
    <use from="&impl_pattern;" type="execution"/>
    <use from="&qual_pattern;" type="validation"/>
    <use from="&rec_pattern;" type="recovery"/>
  </patterns>
  
  <!-- Optimized thinking pattern with abbreviated elements -->
  <think enf="MAND">
    
    <!-- Checkpoint 1: Abbreviated structure -->
    <cp id="1" v="true" enf="BLOCK" tm="int" batch="analysis">
      <act>Analyze requirements and define approach</act>
      <think enf="MAND">
        <pre>What analysis is needed for optimal execution?</pre>
        <crit time="30s">
          - [Context]: What context factors influence the approach?
          - [Approach]: What approach optimizes execution effectiveness?
          - [Parallel]: Can analysis be parallelized for 70% improvement?
        </crit>
        <reason>
          Why is this analysis optimal for the requirements?
          How will this approach maximize execution success?
        </reason>
      </think>
      <parallel batch="analysis" dep="none">
        <opt>Can analysis be batched with research for efficiency?</opt>
        <ctx>How can analysis optimize context window usage?</ctx>
      </parallel>
      <out>ANALYSIS: [approach] with [optimization] for [effectiveness]</out>
      <val>Requirements analyzed with enhanced reasoning</val>
      <enf>BLOCK if analysis insufficient</enf>
    </cp>
    
    <!-- Checkpoint 2: Compressed TDD enforcement -->
    <cp id="2" v="true" enf="BLOCK" tm="std" batch="implementation">
      <act>Execute TDD cycle with RED-GREEN-REFACTOR</act>
      <tdd enf="MAND" red="Write failing tests" green="Minimal implementation" refactor="Improve design"/>
      <parallel batch="implementation" dep="cp1">
        <opt>Can TDD execution be optimized for performance?</opt>
        <ctx>How can TDD cycle optimize context usage?</ctx>
      </parallel>
      <out>TDD_CYCLE: RED=[status] GREEN=[status] REFACTOR=[status]</out>
      <val>TDD cycle completed with quality standards</val>
      <enf>BLOCK if TDD cycle incomplete</enf>
    </cp>
    
    <!-- Checkpoint 3: Validation with quality gates -->
    <cp id="3" v="true" enf="BLOCK" tm="int" batch="validation">
      <act>Validate quality and performance standards</act>
      <gates>
        <gate name="coverage" req="90%" type="test"/>
        <gate name="quality" req="production" type="code"/>
        <gate name="performance" req="200ms" type="response"/>
      </gates>
      <parallel batch="validation" dep="cp2">
        <opt>Can validation be parallelized for efficiency?</opt>
        <ctx>How can validation optimize context window?</ctx>
      </parallel>
      <out>VALIDATION: Coverage=[%] Quality=[level] Performance=[ms]</out>
      <val>All quality gates passed with standards</val>
      <enf>BLOCK if any quality gate fails</enf>
    </cp>
    
  </think>
  
  <!-- Compressed module execution -->
  <modules enf="MAND" tm="int" opt="context_hier">
    <core order="seq" opt="context_hier">
      <mod cache="pred" batch="core">quality/critical-thinking.md</mod>
      <mod cache="pred" batch="core">quality/tdd.md</mod>
      <mod cache="pred" batch="core">development/task-management.md</mod>
    </core>
    <ctx eval="cond" analysis="claude4">
      <if cond="complex_task" mod="patterns/session-management.md" batch="session"/>
      <if cond="code_changes" mod="quality/pre-commit.md" batch="quality"/>
      <if cond="framework_opt" mod="frameworks/rise.md" batch="framework"/>
    </ctx>
    <support order="par" batch="mand" speedup="70%">
      <mod batch="analysis" tools="Read,Grep">patterns/pattern-library.md</mod>
      <mod batch="validation" tools="quality_gates">quality/universal-quality-gates.md</mod>
    </support>
  </modules>
  
  <!-- Compressed TDD integration -->
  <tdd enf="MAND" red="Tests first" green="Minimal code" refactor="Improve design">
    <phase name="red" req="failing_tests" val="Tests fail correctly"/>
    <phase name="green" req="passing_tests" val="All tests pass"/>
    <phase name="refactor" req="improved_code" val="Design enhanced"/>
    <block>
      <cond>Implementation before tests</cond>
      <cond>Tests pass without implementation</cond>
      <cond>Refactoring breaks tests</cond>
    </block>
  </tdd>
  
  <!-- Compressed rules with priorities -->
  <rules enf="STRICT">
    <rule pri="CRIT">Write failing tests BEFORE implementation</rule>
    <rule pri="CRIT">Never write code without test coverage</rule>
    <rule pri="HIGH">90%+ test coverage mandatory</rule>
    <rule pri="HIGH">Quality gates from production standards</rule>
  </rules>
  
  <!-- Optimized pattern usage -->
  <usage>
    <pattern>tdd_cycle - Explicit RED-GREEN-REFACTOR enforcement</pattern>
    <pattern>parallel_exec - File operations optimization</pattern>
    <pattern>single_resp - Component responsibility pattern</pattern>
    <pattern>explicit_val - Error handling validation</pattern>
  </usage>
  
  <!-- Compressed performance monitoring -->
  <perf>
    <metric name="exec_time" target="70% improvement"/>
    <metric name="ctx_eff" target="token optimization"/>
    <metric name="think_qual" target="enhanced reasoning"/>
    <metric name="tdd_comp" target="100% enforcement"/>
  </perf>
  
  <!-- Optimized prompt construction -->
  <prompt>
    <assembly>
      OPTIMIZED WORKFLOW:
      Analysis ‚Üí TDD Cycle ‚Üí Validation ‚Üí Quality Gates
    </assembly>
    <ctx_budget>
      Est: ~8,000 tokens (33% reduction)
      - Analysis: 1,200 (was 2,000)
      - TDD cycle: 4,000 (was 7,000)
      - Validation: 1,500 (was 2,000)
      - Output: 1,300 (was 1,000)
    </ctx_budget>
  </prompt>
  
  <!-- Runtime visualization -->
  <runtime>
    <trace>
      [00:00] ‚ñ∂Ô∏è START: Optimized execution
      [00:15] ‚úì Analysis: Requirements processed (batch optimized)
      [00:30] üî¥ RED: Tests failing as expected
      [00:45] ‚úÖ GREEN: Implementation complete
      [01:00] üîß REFACTOR: Design improved
      [01:15] ‚úÖ COMPLETE: All gates passed
    </trace>
  </runtime>
  
  <!-- Claude 4 interpretation guidance -->
  <claude4>
    <parse>
      1. Process checkpoints sequentially with parallel optimization
      2. Execute critical thinking with enhanced reasoning
      3. Apply TDD enforcement with blocking validation
      4. Validate quality gates with production standards
      5. Optimize context window usage throughout
    </parse>
    <decisions>
      - Checkpoint failures ‚Üí enforcement actions
      - TDD violations ‚Üí blocking prevention
      - Quality failures ‚Üí gate enforcement
      - Parallel opportunities ‚Üí execution optimization
    </decisions>
  </claude4>
  
</command>

<!-- Performance Comparison -->
<!--
Original Structure:
- ~400 lines of XML
- ~12,000 tokens
- Sequential processing
- Nested element heavy

Optimized Structure:
- ~200 lines of XML (50% reduction)
- ~8,000 tokens (33% reduction)
- Parallel processing hints
- Attribute-based design

Performance Gains:
- 33% token reduction
- 70% parallel execution improvement
- 50% XML structure reduction
- Enhanced Claude 4 parsing
-->