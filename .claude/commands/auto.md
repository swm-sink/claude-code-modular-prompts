| version | last_updated | status |
|---------|--------------|--------|
| 3.0.0   | 2025-07-08   | stable |

# /auto - Intelligent routing with framework selection intelligence

────────────────────────────────────────────────────────────────────────────────

```xml
<command purpose="Intelligent routing with framework selection intelligence and research-first approach">
  
  <delegation target="modules/patterns/intelligent-routing.md">
    Analyze request → Select optimal framework → Calculate complexity → Research deeply → Route to optimal command with framework integration
  </delegation>
  
  <thinking_pattern enforcement="MANDATORY">
    <checkpoint id="1" verify="true" enforcement="BLOCKING" thinking_mode="interleaved">
      <action>Parse request and identify task characteristics for framework selection</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What exactly needs to be analyzed before framework selection?
          - What context and constraints apply to this routing decision?
          - How does this connect to framework selection and complexity scoring?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Primary Question: What exactly is being requested and what type of work is this?]
          - [Context Question: What domain does this fall into (technical/business/UX/research)?]
          - [Complexity Question: What's the complexity level (simple/moderate/complex)?]
          - [Interaction Question: What interaction style would be most effective (directive/collaborative/exploratory)?]
          - [TDD Question: Does this require code changes that need TDD enforcement?]
          - [Framework Question: Which framework characteristics are suggested by this request?]
        </critical_thinking>
        <decision_reasoning>
          - Why is this domain classification optimal for framework selection?
          - What evidence supports this complexity assessment?
          - How will this analysis guide framework selection success?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can request analysis be combined with initial framework evaluation?</tool_optimization>
        <context_efficiency>How can this checkpoint optimize token usage for routing?</context_efficiency>
        <dependency_analysis>What analysis is sequential vs parallel for framework selection?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>REQUEST_ANALYSIS: [type] in [domain] with [complexity] requiring [interaction_style] and [tdd_requirement]</output_format>
      <validation>Request analyzed across all framework selection dimensions with enhanced reasoning</validation>
      <enforcement>BLOCK if insufficient analysis for framework selection</enforcement>
      <context_transfer>Request characteristics for framework selection evaluation</context_transfer>
    </checkpoint>
    <checkpoint id="2" verify="true" enforcement="BLOCKING" thinking_mode="extended">
      <action>Select optimal framework using framework selector intelligence</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What framework selection criteria need evaluation?
          - What domain and complexity factors guide framework choice?
          - How does framework selection impact routing optimization?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Primary Question: Based on complexity assessment, which frameworks are most suitable?]
          - [Domain Question: Does the domain (technical/business/UX/research) suggest specific frameworks?]
          - [Interaction Question: What interaction style will yield the best results?]
          - [Strategy Question: Should I use a single framework or combination strategy?]
          - [Routing Question: How does framework choice affect routing decision?]
          - [Optimization Question: Will selected framework optimize execution effectiveness?]
        </critical_thinking>
        <decision_reasoning>
          - Why is this framework optimal for the identified characteristics?
          - What evidence supports this framework selection over alternatives?
          - How will this framework enhance routing and execution success?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can framework evaluation be parallelized with complexity analysis?</tool_optimization>
        <context_efficiency>How can framework selection optimize context window usage?</context_efficiency>
        <dependency_analysis>What framework evaluation can be done in parallel vs sequential?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>FRAMEWORK_SELECTION: Primary=[framework] Secondary=[alternatives] Strategy=[single/combination] Reasoning=[justification]</output_format>
      <validation>Framework selection justified and appropriate for task characteristics with enhanced reasoning</validation>
      <enforcement>BLOCK if framework selection lacks clear justification</enforcement>
      <context_transfer>Selected framework and reasoning for complexity scoring</context_transfer>
    </checkpoint>
    <checkpoint id="3" verify="true" enforcement="BLOCKING" thinking_mode="standard">
      <action>Calculate complexity score with framework and TDD overhead</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What complexity factors need assessment for accurate routing?
          - How does framework selection impact complexity calculation?
          - What TDD overhead needs to be included in scoring?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Base Question: Components×5 + integrations×4 + security×3 = base score]
          - [Framework Question: Add framework complexity overhead based on selected framework]
          - [TDD Question: Add +2 for each component requiring new tests]
          - [Integration Question: Add +3 for each integration requiring test coordination]
          - [Validation Question: Does complexity justify current framework choice and routing?]
          - [Optimization Question: Is scoring optimized for parallel execution assessment?]
        </critical_thinking>
        <decision_reasoning>
          - Why does this complexity score accurately reflect routing needs?
          - What evidence supports framework overhead calculation?
          - How will this score guide optimal command selection?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can complexity scoring be done in parallel with research preparation?</tool_optimization>
        <context_efficiency>How can scoring optimize token usage for routing decision?</context_efficiency>
        <dependency_analysis>What scoring components can be parallelized?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>COMPLEXITY_SCORE: [number] ([base] + [framework_overhead] + [tdd_overhead]) = [total]</output_format>
      <validation>Score calculated with framework and TDD complexity factors with enhanced reasoning</validation>
      <enforcement>VERIFY complexity includes framework optimization considerations</enforcement>
      <context_transfer>Complexity score and framework choice for research and routing</context_transfer>
    </checkpoint>
    <checkpoint id="4" verify="true" enforcement="BLOCKING" thinking_mode="interleaved">
      <action>Research codebase if needed for framework-aware routing</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What research is needed to validate framework and routing choice?
          - What existing patterns might inform framework optimization?
          - How can research improve routing decision quality?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Impact Question: What existing code/patterns would be affected?]
          - [Alignment Question: Are there existing patterns that align with selected framework?]
          - [Architecture Question: Do I need to understand current architecture before framework-optimized routing?]
          - [Optimization Question: Would research-first help optimize framework selection and routing?]
          - [Parallel Question: Can research be done in parallel with other preparations?]
          - [Context Question: How can research optimize context window usage?]
        </critical_thinking>
        <decision_reasoning>
          - Why is this research level appropriate for framework-aware routing?
          - What evidence supports the research approach?
          - How will research findings enhance routing success?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can research operations be batched for 70% performance improvement?</tool_optimization>
        <context_efficiency>How can research optimize context window usage for routing?</context_efficiency>
        <dependency_analysis>What research can be done in parallel vs sequential?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>RESEARCH_STATUS: [NEEDED/COMPLETE] - [findings relevant to framework and routing]</output_format>
      <validation>Research completed with framework optimization insights and enhanced reasoning</validation>
      <enforcement>BLOCK routing until framework-aware research confirms approach</enforcement>
      <context_transfer>Research insights for framework-optimized routing decision</context_transfer>
    </checkpoint>
    <checkpoint id="5" verify="true" enforcement="BLOCKING" thinking_mode="interleaved">
      <action>Route with framework integration and TDD enforcement</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What routing thresholds apply to the calculated complexity score?
          - How does framework selection optimize routing decision?
          - What TDD enforcement level is needed for the target command?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Routing Question: ≤2: /query with LEAP/CLEAR frameworks (research-focused)]
          - [Development Question: 3-9: /task with RISE/CARE frameworks (structured development)]
          - [Feature Question: 10-14: /feature with SOAR/CLEAR frameworks (comprehensive development)]
          - [Coordination Question: ≥15: /swarm with TRACE/BRIDGE frameworks (multi-agent coordination)]
          - [Compatibility Question: Does routed command support selected framework effectively?]
          - [Optimization Question: Will routing choice optimize execution performance?]
        </critical_thinking>
        <decision_reasoning>
          - Why is this routing decision optimal for the complexity and framework?
          - What evidence supports framework compatibility with target command?
          - How will this routing enhance execution success?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can routing validation be done in parallel with command preparation?</tool_optimization>
        <context_efficiency>How can routing optimize context window usage for execution?</context_efficiency>
        <dependency_analysis>What routing validation can be parallelized?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>ROUTING_DECISION: Score [number] → /[command] with [framework] (TDD: [level], Framework: [optimization])</output_format>
      <validation>Route integrates framework selection with TDD enforcement and enhanced reasoning</validation>
      <enforcement>VERIFY target command has framework integration capabilities</enforcement>
      <context_transfer>Routing decision with framework and TDD specifications for execution</context_transfer>
    </checkpoint>
    <checkpoint id="6" verify="true" enforcement="BLOCKING" thinking_mode="interleaved">
      <action>Execute framework-optimized routing with comprehensive delegation</action>
      <interleaved_thinking enforcement="MANDATORY">
        <pre_analysis>
          - What execution requirements need validation before delegation?
          - How does framework integration optimize execution quality?
          - What quality gates ensure framework and TDD success?
        </pre_analysis>
        <critical_thinking minimum_time="30_seconds">
          - [Support Question: Does the target command support the selected framework?]
          - [Integration Question: Will framework integration optimize execution quality?]
          - [Quality Question: Are quality gates configured for framework validation?]
          - [Optimization Question: Is execution path optimized for framework and TDD success?]
          - [Performance Question: Will execution leverage parallel optimization opportunities?]
          - [Context Question: Is execution optimized for context window efficiency?]
        </critical_thinking>
        <decision_reasoning>
          - Why is this execution delegation optimal for framework and TDD success?
          - What evidence supports target command capabilities?
          - How will this delegation maximize execution effectiveness?
        </decision_reasoning>
      </interleaved_thinking>
      <parallel_execution_considerations>
        <tool_optimization>Can execution delegation be optimized for parallel tool usage?</tool_optimization>
        <context_efficiency>How can delegation optimize context window usage for target command?</context_efficiency>
        <dependency_analysis>What delegation components can be parallelized?</dependency_analysis>
      </parallel_execution_considerations>
      <output_format>EXECUTION_DELEGATION: Routing to /[command] with framework=[selected] TDD=[confirmed] optimization=[enabled]</output_format>
      <validation>Target command confirmed for framework and TDD capabilities with enhanced reasoning</validation>
      <enforcement>BLOCK if target lacks framework integration or TDD enforcement</enforcement>
      <context_transfer>Complete delegation with framework optimization and TDD enforcement</context_transfer>
    </checkpoint>
  </thinking_pattern>
  
  <tdd_integration enforcement="MANDATORY">
    <routing_tdd_awareness>Route to TDD-enforcing commands for code changes, research commands for analysis</routing_tdd_awareness>
    <complexity_adjustment>Include TDD overhead in complexity scoring for accurate routing</complexity_adjustment>
    <command_verification>Verify target commands have proper TDD enforcement before routing</command_verification>
    <validation>Reference quality/tdd.md#routing_considerations for TDD-aware routing</validation>
    <blocking_conditions>
      <condition>Routing code changes to non-TDD-enforcing commands</condition>
      <condition>Complexity calculation ignores TDD testing requirements</condition>
      <condition>Target command lacks adequate TDD enforcement capabilities</condition>
      <condition>Research bypassed when TDD approach unclear</condition>
    </blocking_conditions>
  </tdd_integration>
  
  <claude_4_module_execution enforcement="MANDATORY" thinking_mode="interleaved">
    <core_stack order="advanced_sequential" optimization="context_hierarchical">
      <module thinking="enabled" cache="predictive">quality/critical-thinking.md - Claude 4 enhanced 30-second analysis before routing decision</module>
      <module thinking="enabled" cache="predictive">frameworks/framework-selector.md - Intelligent framework selection with multi-factor analysis</module>
      <module thinking="enabled" cache="predictive">patterns/intelligent-routing.md - Framework-aware request analysis with complexity scoring</module>
      <module thinking="enabled" cache="predictive">quality/tdd.md - TDD-aware routing considerations with framework integration</module>
      <module thinking="enabled" cache="predictive">patterns/pattern-library.md - Proven execution patterns with Claude 4 optimization</module>
    </core_stack>
    <contextual_modules evaluation="intelligent_conditional" analysis="claude_4_enhanced">
      <conditional module="frameworks/rise.md" condition="structured_approach_needed" thinking="adaptive" fallback="frameworks/trace.md"/>
      <conditional module="frameworks/trace.md" condition="precision_specification_needed" thinking="adaptive" fallback="frameworks/care.md"/>
      <conditional module="frameworks/care.md" condition="outcome_validation_needed" thinking="adaptive" fallback="frameworks/rise.md"/>
      <conditional module="frameworks/advanced-frameworks.md" condition="specialized_framework_needed" thinking="adaptive" fallback="patterns/intelligent-routing.md"/>
      <conditional module="development/research-analysis.md" condition="research_needed" thinking="adaptive" fallback="patterns/intelligent-routing.md"/>
      <conditional module="quality/error-recovery.md" condition="routing_failures" thinking="adaptive" fallback="patterns/session-management.md"/>
      <conditional module="patterns/session-management.md" condition="complex_routing" thinking="adaptive" fallback="quality/critical-thinking.md"/>
      <conditional module="meta/adaptive-router.md" condition="learning_optimization_needed" thinking="adaptive" fallback="patterns/intelligent-routing.md"/>
    </contextual_modules>
    <support_modules order="optimized_parallel" batching="mandatory" speedup="70_percent">
      <module batch_group="analysis" tools="Read,Grep">patterns/pattern-library.md - Parallel pattern analysis</module>
      <module batch_group="validation" tools="quality_gates">quality/universal-quality-gates.md - Concurrent quality validation</module>
    </support_modules>
    <performance_monitoring>
      <metric name="execution_time" target="70_percent_improvement"/>
      <metric name="context_efficiency" target="token_optimization"/>
      <metric name="thinking_quality" target="enhanced_reasoning"/>
      <metric name="routing_accuracy" target="95_percent_success"/>
    </performance_monitoring>
  </claude_4_module_execution>
  
  <meta_framework_capabilities enforcement="MANDATORY">
    <adaptive_routing integration="meta/adaptive-router.md">
      <learning_engine>Usage pattern recognition and routing optimization</learning_engine>
      <performance_tracking>95% routing accuracy with continuous improvement</performance_tracking>
      <context_awareness>Intelligent routing based on user patterns and success rates</context_awareness>
      <failure_learning>Adaptive routing improvement based on failure analysis</failure_learning>
    </adaptive_routing>
    
    <intelligent_framework_evolution>
      <framework_effectiveness>Track framework success rates by context and complexity</framework_effectiveness>
      <combination_optimization>Learn optimal framework combinations through usage patterns</combination_optimization>
      <user_preference_adaptation>Adapt framework selection to user working styles</user_preference_adaptation>
      <predictive_selection>Anticipate optimal framework choices based on request patterns</predictive_selection>
    </intelligent_framework_evolution>
    
    <meta_optimization_features>
      <routing_prediction>Predict optimal routing based on historical success patterns</routing_prediction>
      <complexity_refinement>Refine complexity scoring based on routing outcome analysis</complexity_refinement>
      <framework_tuning>Optimize framework selection criteria based on effectiveness data</framework_tuning>
      <adaptive_thresholds>Adjust routing thresholds based on performance feedback</adaptive_thresholds>
    </meta_optimization_features>
    
    <safety_boundaries enforcement="CRITICAL">
      <core_routing_protection>Original routing logic always available as fallback</core_routing_protection>
      <human_override>User can override any routing decision or framework selection</human_override>
      <rollback_capability>Instant rollback to previous routing behavior if needed</rollback_capability>
      <validation_gates>All meta-enhancements validated against safety boundaries</validation_gates>
    </safety_boundaries>
  </meta_framework_capabilities>

  <depends_on>
    frameworks/framework-selector.md for intelligent framework selection
    patterns/intelligent-routing.md for framework-aware analysis and routing
    frameworks/rise.md, frameworks/trace.md, frameworks/care.md for foundational frameworks
    frameworks/advanced-frameworks.md for specialized framework ecosystem
    quality/tdd.md for TDD-aware routing with framework integration
    patterns/pattern-library.md for proven execution patterns
    quality/error-recovery.md for resilient execution
    meta/adaptive-router.md for self-improving routing intelligence
    meta/safety-validator.md for meta-framework safety boundaries
    meta/human-oversight.md for human control and intervention
    quality/universal-quality-gates.md for enhanced quality enforcement
    All commands and modules for dynamic routing decisions
  </depends_on>
  
  <examples>
    /auto "Add user authentication"     → CRISP framework → Score ~12 → Routes to /task with technical precision
    /auto "Build e-commerce platform"   → BRIDGE framework → Score 40+ → Routes to /swarm with integration focus
    /auto "How does caching work?"      → LEAP framework → Score 1 → Routes to /query with learning approach
    /auto "Create API endpoints"        → RISE framework → Score ~10 → Routes to /feature with structured development
    /auto "Debug payment failures"     → SPARK framework → Score ~8 → Routes to /task with problem-solving focus
    /auto "Plan user experience redesign" → FOCUS framework → Score ~15 → Routes to /swarm with user-centered approach
  </examples>
  
  <rules>
    <rule>ALWAYS select optimal framework before routing</rule>
    <rule>ALWAYS calculate complexity score with framework considerations</rule>
    <rule>ALWAYS research first for informed framework-aware decisions</rule>
    <rule>NEVER skip framework selection or complexity scoring algorithm</rule>
    <rule>ALWAYS validate framework compatibility with target command</rule>
  </rules>
  
  <pattern_usage>
    • Uses intelligent_selection pattern for framework choice
    • Implements three_x_rule pattern for routing decisions
    • Applies consequence_mapping for impact analysis
    • Leverages parallel_execution for research operations
    • Uses explicit_validation pattern with framework verification
    • Integrates smart_memoization for cached framework and routing decisions
    • Applies error_recovery for resilient framework-aware routing
    • Uses framework_optimization patterns for enhanced execution
    
    See modules/frameworks/framework-selector.md for framework selection details
    See modules/patterns/pattern-library.md for pattern details
    See modules/patterns/intelligent-routing.md for full implementation
  </pattern_usage>
  

  <prompt_construction>
    <assembly_preview>
      FRAMEWORK-AWARE WORKFLOW ASSEMBLY:
      ┌─────────────────┐
      │ 1. Request     │ → Parse & categorize request with domain/complexity analysis
      └────────┬────────┘
               ↓
      ┌─────────────────┐
      │ 2. Framework   │ → Intelligent framework selection using task characteristics
      │   Selection    │
      └────────┬────────┘
               ↓
      ┌─────────────────┐
      │ 3. Complexity  │ → Calculate routing score with framework overhead
      └────────┬────────┘
               ↓
      ┌─────────────────┐
      │ 4. Research    │ → Framework-aware pattern investigation
      └────────┬────────┘
               ↓
      ┌─────────────────┐
      │ 5. Route       │ → Framework-optimized command selection
      └────────┬────────┘
               ↓
      ┌─────────────────┐
      │ 6. Execute     │ → Framework-integrated execution with TDD enforcement
      └─────────────────┘
    </assembly_preview>

    <context_budget>
      Estimated tokens: ~10,000
      - Request analysis: 1,500
      - Framework selection: 2,000
      - Complexity scoring: 1,000
      - Research phase: 4,000
      - Routing decision: 1,500
    </context_budget>
  </prompt_construction>

  <runtime_visualization>
    <execution_trace>
      [00:00] ▶️ START: /auto "Build payment system"
      [00:15] 🔍 ANALYSIS: Multi-component financial system detected (domain: technical, complexity: high)
      [00:25] 🎯 FRAMEWORK: Selected BRIDGE framework for complex integration approach
      [00:40] 📊 COMPLEXITY: Score 95/100 → High complexity (base: 85, framework: +5, TDD: +5)
      [00:55] 📚 RESEARCH: Framework-aware analysis of payment patterns and compliance
      [01:40] 🚀 ROUTING: Escalating to /swarm with BRIDGE framework integration
      [01:45] ✅ COMPLETE: Routed with framework optimization and TDD enforcement
    </execution_trace>
  </runtime_visualization>

  <claude_4_interpretation>
    <parsing_behavior>
      1. Reads checkpoint structure sequentially
      2. Executes critical_thinking questions internally
      3. Formats output according to output_format specifications
      4. Validates against enforcement rules before proceeding
      5. Applies parallel execution optimization where possible
    </parsing_behavior>

    <decision_points>
      - Checkpoint failures trigger enforcement actions
      - Module selection based on contextual conditions
      - Parallel execution for independent operations
      - Quality gate validation at completion boundaries
      - Error recovery through graceful degradation paths
    </decision_points>
  </claude_4_interpretation>

</command>
```