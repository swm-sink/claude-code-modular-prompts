#!/bin/bash
# Agent Invocation System - Individual Agent Execution
# Purpose: Execute individual specialized agents with context and constraints

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AGENTS_DIR="${SCRIPT_DIR}/../.claude/agents"
CONTEXT_DIR="${SCRIPT_DIR}/../.claude/context" 
SESSION_STATE_FILE="${SCRIPT_DIR}/../.claude/consultation-state.json"

# Logging setup
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INVOKE-AGENT: $1" >&2
}

# Usage function
usage() {
    echo "Usage: $0 [agent-name] [project-path]"
    echo ""
    echo "Available Agents:"
    echo "  context-engineer   Analyze project architecture and create context structures"
    echo "  command-builder    Create project-specific Claude Code commands"
    echo "  research-validator Validate patterns with evidence-based research"
    echo ""
    exit 1
}

# Load agent definition
load_agent_definition() {
    local agent_name="$1"
    local agent_file="${AGENTS_DIR}/${agent_name}.md"
    
    if [ ! -f "$agent_file" ]; then
        log "ERROR: Agent definition not found: $agent_file"
        exit 1
    fi
    
    log "Loading agent definition: $agent_name"
    
    # Extract agent specialization and constraints
    AGENT_DOMAIN=$(grep -A1 "Agent Specialization" "$agent_file" | tail -1 | sed 's/\*\*Domain\*\*: //')
    AGENT_BOUNDARY=$(grep -A1 "Agent Specialization" "$agent_file" | grep "Boundary" | sed 's/\*\*Boundary\*\*: //')
    
    log "Agent loaded - Domain: $AGENT_DOMAIN"
}

# Prepare project context for agent
prepare_project_context() {
    local project_path="$1"
    local agent_name="$2"
    
    log "Preparing project context for agent: $agent_name"
    
    # Create agent-specific context directory
    AGENT_CONTEXT_DIR="${CONTEXT_DIR}/${agent_name}"
    mkdir -p "$AGENT_CONTEXT_DIR"
    
    # Basic project analysis (minimal implementation)
    if [ -n "$project_path" ] && [ -d "$project_path" ]; then
        log "Analyzing project structure at: $project_path"
        
        # Create basic project analysis
        cat > "${AGENT_CONTEXT_DIR}/project-analysis.md" << EOF
# Project Analysis for ${agent_name}

## Project Path
$project_path

## Directory Structure
$(find "$project_path" -maxdepth 2 -type d 2>/dev/null | head -20)

## Key Files Detected
$(find "$project_path" -maxdepth 3 -name "*.json" -o -name "*.md" -o -name "*.yml" -o -name "*.yaml" 2>/dev/null | head -10)

## Framework Indicators
$(find "$project_path" -name "package.json" -o -name "requirements.txt" -o -name "Gemfile" -o -name "pom.xml" 2>/dev/null)

## Analysis Timestamp
$(date '+%Y-%m-%d %H:%M:%S')
EOF
        
        log "Project analysis prepared at: ${AGENT_CONTEXT_DIR}/project-analysis.md"
    else
        log "WARNING: Project path not provided or invalid: $project_path"
    fi
}

# Execute agent analysis
execute_agent() {
    local agent_name="$1" 
    local project_path="$2"
    
    log "Executing agent: $agent_name"
    
    # Update session state - mark agent as running
    update_session_state "$agent_name" "running"
    
    # Agent-specific execution logic
    case "$agent_name" in
        "context-engineer")
            execute_context_engineer "$project_path"
            ;;
        "command-builder")
            execute_command_builder "$project_path"
            ;;
        "research-validator")
            execute_research_validator "$project_path"
            ;;
        *)
            log "ERROR: Unknown agent: $agent_name"
            exit 1
            ;;
    esac
    
    # Update session state - mark agent as complete
    update_session_state "$agent_name" "completed"
    
    log "Agent execution complete: $agent_name"
}

# Context Engineer execution
execute_context_engineer() {
    local project_path="$1"
    
    log "Context Engineer: Analyzing project architecture"
    
    # Create basic context structure (minimal implementation)
    cat > "${CONTEXT_DIR}/technical-architecture.md" << EOF
# Technical Architecture Analysis

Generated by Context Engineer agent at $(date '+%Y-%m-%d %H:%M:%S')

## Project Structure Analysis
$(if [ -n "$project_path" ]; then echo "Project analyzed: $project_path"; else echo "No project path provided"; fi)

## Framework Detection
$(if [ -n "$project_path" ] && [ -f "$project_path/package.json" ]; then echo "Node.js project detected"; fi)
$(if [ -n "$project_path" ] && [ -f "$project_path/requirements.txt" ]; then echo "Python project detected"; fi)

## Context Structure
This is a minimal implementation - full context engineering requires project-specific analysis.

## Navigation Patterns
- Technical architecture: This file
- Project structure: Directory analysis available
- Framework patterns: Based on detected technologies
EOF
    
    log "Context Engineer: Technical architecture analysis complete"
}

# Command Builder execution
execute_command_builder() {
    local project_path="$1"
    
    log "Command Builder: Creating project-specific commands"
    
    # Create basic command integration plan
    cat > "${CONTEXT_DIR}/command-integration.md" << EOF
# Command Integration Strategy

Generated by Command Builder agent at $(date '+%Y-%m-%d %H:%M:%S')

## Custom Commands Analysis
Based on project analysis, the following command opportunities were identified:

## Project-Specific Workflows
$(if [ -n "$project_path" ]; then echo "Project analyzed: $project_path"; else echo "No project path provided for analysis"; fi)

## Command Recommendations
This is a minimal implementation - full command building requires domain-specific analysis.

## Integration Points
- Existing Claude Code command structure
- Project workflow patterns  
- Framework-specific integrations
EOF
    
    log "Command Builder: Command integration strategy complete"
}

# Research Validator execution  
execute_research_validator() {
    local project_path="$1"
    
    log "Research Validator: Validating patterns with evidence"
    
    # Create basic research validation
    cat > "${CONTEXT_DIR}/research-evidence.md" << EOF
# Research Evidence Summary

Generated by Research Validator agent at $(date '+%Y-%m-%d %H:%M:%S')

## Validation Scope
$(if [ -n "$project_path" ]; then echo "Project analyzed: $project_path"; else echo "No specific project provided for validation"; fi)

## Evidence Requirements
All technical claims require validation with 3+ authoritative sources using CRAAP methodology.

## Validation Status
This is a minimal implementation - full research validation requires specific claims to validate.

## Source Credibility
- Industry standards organizations
- Framework official documentation  
- Peer-reviewed technical resources
EOF
    
    log "Research Validator: Evidence validation complete"
}

# Update session state
update_session_state() {
    local agent_name="$1"
    local status="$2"
    
    if [ -f "$SESSION_STATE_FILE" ]; then
        # Simple status update (basic implementation)
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        log "Updating session state: $agent_name -> $status"
        
        # Note: This is a simplified implementation
        # Full implementation would use proper JSON manipulation
    else
        log "WARNING: Session state file not found: $SESSION_STATE_FILE"
    fi
}

# Main execution
main() {
    local agent_name="$1"
    local project_path="$2"
    
    if [ $# -lt 1 ]; then
        usage
    fi
    
    # Validate agent exists
    if [ ! -f "${AGENTS_DIR}/${agent_name}.md" ]; then
        log "ERROR: Agent not found: $agent_name"
        log "Available agents:"
        ls -1 "${AGENTS_DIR}"/*.md 2>/dev/null | xargs -n1 basename | sed 's/.md$//' || log "No agents found"
        exit 1
    fi
    
    # Execute agent workflow
    load_agent_definition "$agent_name"
    prepare_project_context "$project_path" "$agent_name"
    execute_agent "$agent_name" "$project_path"
    
    log "Agent invocation complete: $agent_name"
}

# Execute if run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi