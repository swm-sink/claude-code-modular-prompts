# Sequential Workflow Orchestration
# Claude Context Architect - Deep Discovery Generation Engine
# Version: 1.0
# Purpose: Define sequential agent workflow patterns and coordination chains

metadata:
  version: "1.0"
  created: "2025-08-07"
  system: "Claude Context Architect Agent Coordination"
  purpose: "Sequential multi-agent workflow orchestration patterns"
  performance_requirement: "<500ms workflow transition overhead"

# =============================================================================
# CORE SEQUENTIAL ORCHESTRATION FRAMEWORK
# =============================================================================

sequential_orchestration_framework:
  orchestration_model:
    chain_based: "agents_execute_in_predetermined_sequence"
    dependency_driven: "next_agent_activated_when_dependencies_satisfied"
    milestone_triggered: "workflow_advances_on_milestone_completion"
    conditional_branching: "workflow_path_determined_by_intermediate_results"
    
  coordination_mechanisms:
    handoff_protocols: "structured_data_transfer_between_agents"
    validation_checkpoints: "quality_gates_between_workflow_steps"
    rollback_capabilities: "ability_to_reverse_workflow_steps"
    error_propagation: "failure_handling_across_workflow_chain"
    
  workflow_persistence:
    state_tracking: "maintain_workflow_progress_state"
    checkpoint_creation: "save_workflow_state_at_milestones"
    recovery_mechanisms: "resume_workflows_from_checkpoints"
    audit_trails: "complete_workflow_execution_history"

# =============================================================================
# FUNDAMENTAL WORKFLOW PATTERNS
# =============================================================================

fundamental_patterns:
  
  linear_sequential:
    description: "Simple linear sequence of agents"
    pattern_structure: "Agent1 → Agent2 → Agent3 → ... → AgentN"
    use_cases:
      - "Basic analysis to implementation flow"
      - "Document generation pipeline" 
      - "Quality assurance chain"
    
    coordination_requirements:
      strict_ordering: true
      parallel_execution: false
      dependency_validation: "previous_step_must_complete_successfully"
      rollback_support: "reverse_execution_order"
    
    example_implementation:
      workflow_name: "basic_feature_development"
      sequence:
        1:
          agent: "architecture_agent"
          task: "analyze_feature_requirements"
          input: "user_requirements"
          output: "architectural_design"
          validation: "design_completeness_check"
          
        2:
          agent: "code_generation_agent"
          task: "implement_feature_scaffolding"
          input: "architectural_design"
          output: "feature_code_skeleton"
          validation: "code_structure_validation"
          
        3:
          agent: "testing_agent"
          task: "create_test_suite"
          input: "feature_code_skeleton"
          output: "comprehensive_tests"
          validation: "test_coverage_verification"
          
        4:
          agent: "documentation_agent"
          task: "generate_feature_documentation"
          input: ["architectural_design", "feature_code_skeleton"]
          output: "feature_documentation"
          validation: "documentation_completeness"
  
  conditional_sequential:
    description: "Sequential flow with conditional branching"
    pattern_structure: "Agent1 → [Decision Point] → {AgentA | AgentB | AgentC} → ..."
    use_cases:
      - "Different workflows based on project type"
      - "Error handling and recovery paths"
      - "Optimization paths based on analysis results"
    
    coordination_requirements:
      decision_logic: "rule_based_path_selection"
      condition_evaluation: "automated_decision_making"
      path_convergence: "multiple_paths_join_at_common_agent"
      dynamic_routing: "runtime_workflow_path_determination"
    
    example_implementation:
      workflow_name: "adaptive_optimization_flow"
      sequence:
        1:
          agent: "performance_agent"
          task: "analyze_performance_bottlenecks"
          output: "performance_analysis"
          
        decision_point:
          condition_evaluator: "performance_analysis_classifier"
          decision_criteria:
            memory_bottleneck: "memory_usage > 80%"
            cpu_bottleneck: "cpu_usage > 85%"
            database_bottleneck: "query_time > 200ms"
            network_bottleneck: "network_latency > 100ms"
            
        conditional_paths:
          memory_optimization_path:
            2: { agent: "refactoring_agent", task: "optimize_memory_usage" }
            3: { agent: "testing_agent", task: "validate_memory_optimization" }
            
          database_optimization_path:
            2: { agent: "data_agent", task: "optimize_database_queries" }
            3: { agent: "performance_agent", task: "validate_query_performance" }
            
          network_optimization_path:
            2: { agent: "integration_agent", task: "optimize_api_calls" }
            3: { agent: "performance_agent", task: "validate_network_optimization" }
            
        convergence_point:
          4:
            agent: "documentation_agent"
            task: "document_optimization_results"
  
  iterative_sequential:
    description: "Sequential workflow with iterative refinement"
    pattern_structure: "Agent1 → Agent2 → ... → AgentN → [Quality Check] → [Loop back if needed]"
    use_cases:
      - "Iterative quality improvement"
      - "TDD red-green-refactor cycles"
      - "Incremental feature development"
    
    coordination_requirements:
      iteration_control: "automated_iteration_termination_criteria"
      quality_assessment: "objective_quality_measurement"
      improvement_tracking: "monitor_quality_improvements_per_iteration"
      convergence_detection: "identify_when_further_iterations_unnecessary"
    
    example_implementation:
      workflow_name: "tdd_development_cycle"
      iteration_logic:
        max_iterations: 5
        convergence_criteria: "test_coverage >= 90% AND code_quality_score >= 85"
        improvement_threshold: "quality_improvement < 5% triggers_termination"
        
      sequence_per_iteration:
        1:
          agent: "testing_agent"
          task: "write_failing_tests"
          validation: "tests_fail_as_expected"
          
        2:
          agent: "code_generation_agent"
          task: "implement_minimal_solution"
          validation: "tests_pass"
          
        3:
          agent: "refactoring_agent"
          task: "improve_code_quality"
          validation: "tests_still_pass_after_refactoring"
          
        4:
          agent: "review_agent"
          task: "assess_code_quality"
          output: "quality_metrics"
          
        iteration_decision:
          evaluator: "quality_metrics_analyzer"
          continue_criteria: "quality_score < target_quality OR test_coverage < target_coverage"
          terminate_criteria: "quality_targets_met OR max_iterations_reached"

# =============================================================================
# DOMAIN-SPECIFIC WORKFLOW TEMPLATES
# =============================================================================

domain_specific_workflows:
  
  architecture_analysis_workflow:
    description: "Comprehensive architectural analysis and recommendation"
    total_estimated_duration: "8-12 minutes"
    agents_involved: ["architecture_agent", "performance_agent", "security_agent", "documentation_agent"]
    
    workflow_sequence:
      1:
        agent: "architecture_agent"
        task: "analyze_system_architecture"
        estimated_duration: "3-4 minutes"
        inputs: ["codebase_structure", "dependency_analysis"]
        outputs: ["architecture_assessment", "scalability_analysis", "design_pattern_identification"]
        validation_criteria: "architecture_completeness_score >= 80%"
        
      2:
        agent: "performance_agent"
        task: "evaluate_architectural_performance_implications"
        estimated_duration: "2-3 minutes"
        inputs: ["architecture_assessment"]
        outputs: ["performance_impact_analysis", "bottleneck_predictions"]
        validation_criteria: "performance_analysis_confidence >= 85%"
        
      3:
        agent: "security_agent"
        task: "assess_architectural_security_posture"
        estimated_duration: "2-3 minutes"
        inputs: ["architecture_assessment", "design_pattern_identification"]
        outputs: ["security_vulnerability_analysis", "security_recommendations"]
        validation_criteria: "security_coverage_completeness >= 90%"
        
      4:
        agent: "documentation_agent"
        task: "synthesize_architectural_documentation"
        estimated_duration: "1-2 minutes"
        inputs: ["architecture_assessment", "performance_impact_analysis", "security_vulnerability_analysis"]
        outputs: ["comprehensive_architecture_report", "improvement_roadmap"]
        validation_criteria: "documentation_completeness >= 95%"
    
    success_criteria:
      overall_workflow_success: "all_validation_criteria_met"
      quality_threshold: "combined_agent_confidence >= 85%"
      deliverable_completeness: "all_outputs_generated_and_validated"
      
  code_generation_workflow:
    description: "Project-aware code generation with quality assurance"
    total_estimated_duration: "6-10 minutes"
    agents_involved: ["code_generation_agent", "testing_agent", "review_agent", "documentation_agent"]
    
    workflow_sequence:
      1:
        agent: "code_generation_agent"
        task: "generate_code_following_project_patterns"
        estimated_duration: "3-4 minutes"
        inputs: ["feature_requirements", "project_conventions", "existing_code_patterns"]
        outputs: ["generated_code", "integration_points", "dependency_additions"]
        validation_criteria: "code_compilation_success AND pattern_adherence >= 90%"
        
      2:
        agent: "testing_agent"
        task: "create_comprehensive_test_suite"
        estimated_duration: "2-3 minutes"
        inputs: ["generated_code", "feature_requirements"]
        outputs: ["test_suite", "coverage_report", "edge_case_tests"]
        validation_criteria: "test_coverage >= 90% AND all_tests_pass"
        
      3:
        agent: "review_agent"
        task: "conduct_code_quality_review"
        estimated_duration: "1-2 minutes"
        inputs: ["generated_code", "test_suite"]
        outputs: ["code_quality_assessment", "improvement_recommendations"]
        validation_criteria: "code_quality_score >= 80%"
        
      conditional_step:
        condition: "code_quality_score < 80%"
        action: "return_to_step_1_with_feedback"
        max_iterations: 3
        
      4:
        agent: "documentation_agent"
        task: "generate_code_documentation"
        estimated_duration: "1 minute"
        inputs: ["generated_code", "feature_requirements", "code_quality_assessment"]
        outputs: ["api_documentation", "usage_examples", "integration_guide"]
        validation_criteria: "documentation_completeness >= 85%"
    
    quality_gates:
      compilation_gate: "code_must_compile_without_errors"
      test_coverage_gate: "minimum_90_percent_test_coverage"
      quality_gate: "minimum_code_quality_score_80"
      integration_gate: "successful_integration_with_existing_codebase"
      
  debugging_investigation_workflow:
    description: "Systematic debugging and root cause analysis"
    total_estimated_duration: "5-8 minutes"
    agents_involved: ["debugging_agent", "performance_agent", "testing_agent", "architecture_agent"]
    
    workflow_sequence:
      1:
        agent: "debugging_agent"
        task: "initial_problem_analysis"
        estimated_duration: "2-3 minutes"
        inputs: ["error_reports", "system_logs", "reproduction_steps"]
        outputs: ["problem_classification", "symptom_analysis", "initial_hypotheses"]
        validation_criteria: "problem_classification_confidence >= 80%"
        
      conditional_branching:
        performance_issue_path:
          condition: "problem_classification == 'performance'"
          2:
            agent: "performance_agent"
            task: "detailed_performance_analysis"
            inputs: ["symptom_analysis", "system_metrics"]
            outputs: ["performance_bottleneck_identification"]
            
        architectural_issue_path:
          condition: "problem_classification == 'architectural'"
          2:
            agent: "architecture_agent"
            task: "architectural_flaw_analysis"
            inputs: ["symptom_analysis", "system_design"]
            outputs: ["architectural_issue_identification"]
            
        logic_issue_path:
          condition: "problem_classification == 'logic'"
          2:
            agent: "debugging_agent"
            task: "code_path_analysis"
            inputs: ["symptom_analysis", "code_flow_analysis"]
            outputs: ["logic_error_identification"]
      
      convergence_point:
        3:
          agent: "debugging_agent"
          task: "synthesize_root_cause_analysis"
          inputs: ["specialized_analysis_results"]
          outputs: ["root_cause_identification", "fix_recommendations"]
          
        4:
          agent: "testing_agent"
          task: "create_regression_tests"
          inputs: ["root_cause_identification", "fix_recommendations"]
          outputs: ["regression_test_suite"]

# =============================================================================
# WORKFLOW COORDINATION MECHANISMS
# =============================================================================

coordination_mechanisms:
  
  handoff_protocols:
    structured_handoff:
      handoff_format:
        source_agent: "agent_completing_work"
        target_agent: "agent_receiving_work"
        deliverable_package: "structured_output_from_source"
        validation_results: "source_agent_quality_validation"
        context_information: "relevant_context_for_target_agent"
        success_criteria: "what_target_agent_needs_to_achieve"
        
      handoff_validation:
        completeness_check: "verify_all_required_deliverables_present"
        quality_validation: "validate_deliverables_meet_quality_standards"
        context_verification: "ensure_target_agent_has_necessary_context"
        acceptance_confirmation: "target_agent_confirms_handoff_acceptance"
        
    error_handling_in_handoffs:
      incomplete_deliverables:
        detection: "automated_completeness_validation"
        resolution: "request_additional_work_from_source_agent"
        escalation: "coordinator_intervention_if_multiple_failures"
        
      quality_issues:
        detection: "automated_quality_validation"
        resolution: "return_to_source_agent_for_improvement"
        iteration_limit: "maximum_3_improvement_cycles"
        
      context_misalignment:
        detection: "target_agent_reports_insufficient_context"
        resolution: "provide_additional_context_or_clarification"
        fallback: "coordinator_provides_missing_context"
        
  dependency_management:
    dependency_tracking:
      dependency_graph: "maintain_complete_dependency_relationships"
      dynamic_dependencies: "handle_dependencies_discovered_during_execution"
      circular_dependency_detection: "prevent_workflow_deadlocks"
      
    dependency_resolution:
      prerequisite_validation: "verify_all_prerequisites_satisfied_before_agent_activation"
      parallel_dependency_resolution: "resolve_independent_dependencies_in_parallel"
      dependency_conflict_resolution: "handle_conflicting_dependency_requirements"
      
    dependency_optimization:
      critical_path_identification: "identify_longest_dependency_chain"
      parallel_execution_opportunities: "identify_agents_that_can_run_in_parallel"
      dependency_reordering: "optimize_workflow_order_to_minimize_total_time"
      
  milestone_management:
    milestone_definition:
      milestone_criteria: "objective_measurable_completion_criteria"
      milestone_deliverables: "specific_artifacts_produced_at_milestone"
      milestone_validation: "automated_validation_of_milestone_achievement"
      
    progress_tracking:
      real_time_progress_updates: "continuous_progress_percentage_updates"
      milestone_completion_notifications: "broadcast_milestone_achievements"
      estimated_completion_updates: "dynamic_completion_time_estimates"
      
    quality_gates:
      quality_criteria: "specific_quality_requirements_at_each_milestone"
      automated_quality_assessment: "objective_quality_measurement"
      quality_gate_failure_handling: "procedures_for_quality_gate_failures"

# =============================================================================
# ERROR HANDLING AND RECOVERY
# =============================================================================

error_handling:
  
  agent_failure_scenarios:
    agent_timeout:
      detection: "agent_exceeds_allocated_time_budget"
      immediate_action: "terminate_agent_task"
      recovery_options:
        - "retry_with_extended_timeout"
        - "escalate_to_backup_agent"
        - "skip_step_with_degraded_functionality"
      decision_criteria: "based_on_criticality_and_available_alternatives"
      
    agent_error:
      detection: "agent_reports_unrecoverable_error"
      error_classification: "categorize_error_type_and_severity"
      recovery_strategies:
        transient_error: "retry_after_delay"
        configuration_error: "fix_configuration_and_retry"
        capability_error: "reassign_to_different_agent"
        system_error: "escalate_to_system_administrator"
        
    quality_failure:
      detection: "agent_output_fails_quality_validation"
      improvement_attempts: "allow_up_to_3_improvement_iterations"
      escalation_threshold: "escalate_after_3_failed_improvement_attempts"
      fallback_options:
        - "accept_lower_quality_with_documentation"
        - "skip_step_and_continue_with_warning"
        - "abort_workflow_and_report_failure"
        
  workflow_recovery:
    checkpoint_recovery:
      checkpoint_frequency: "after_each_major_milestone"
      checkpoint_data: "complete_workflow_state_and_intermediate_results"
      recovery_procedure: "restore_workflow_state_and_continue_from_checkpoint"
      
    partial_rollback:
      rollback_granularity: "individual_agent_steps"
      rollback_decision_criteria: "error_impact_analysis"
      rollback_execution: "reverse_agent_actions_in_reverse_order"
      
    graceful_degradation:
      functionality_prioritization: "identify_essential_vs_optional_steps"
      degraded_mode_operation: "continue_with_reduced_functionality"
      user_notification: "inform_user_of_reduced_functionality_and_reasons"
      
  error_propagation:
    upstream_error_handling:
      error_context_preservation: "maintain_error_context_through_workflow_chain"
      error_aggregation: "combine_multiple_related_errors"
      error_translation: "translate_technical_errors_to_user_friendly_messages"
      
    downstream_impact_assessment:
      impact_analysis: "assess_how_error_affects_subsequent_workflow_steps"
      dependency_impact: "identify_dependent_workflows_affected_by_error"
      cascading_failure_prevention: "prevent_errors_from_cascading_through_system"

# =============================================================================
# PERFORMANCE OPTIMIZATION
# =============================================================================

performance_optimization:
  
  workflow_parallelization:
    parallel_opportunity_identification:
      independence_analysis: "identify_agents_with_no_interdependencies"
      resource_availability: "ensure_sufficient_resources_for_parallel_execution"
      coordination_overhead_assessment: "balance_parallelization_benefits_vs_coordination_costs"
      
    parallel_execution_patterns:
      fork_join: "split_workflow_into_parallel_branches_then_merge"
      pipeline: "overlapping_agent_execution_pipeline_style"
      scatter_gather: "distribute_work_across_multiple_agents_then_aggregate"
      
  resource_optimization:
    agent_resource_management:
      resource_pooling: "shared_resource_pools_across_workflows"
      resource_allocation: "dynamic_resource_allocation_based_on_priority"
      resource_contention_resolution: "handle_resource_conflicts_between_workflows"
      
    memory_optimization:
      intermediate_result_management: "optimize_storage_of_intermediate_results"
      garbage_collection: "clean_up_unused_intermediate_results"
      memory_pressure_handling: "graceful_handling_of_memory_pressure"
      
  timing_optimization:
    critical_path_optimization:
      critical_path_identification: "find_longest_time_path_through_workflow"
      bottleneck_identification: "identify_slowest_steps_in_workflow"
      optimization_prioritization: "focus_optimization_efforts_on_critical_path"
      
    scheduling_optimization:
      dynamic_scheduling: "adjust_agent_scheduling_based_on_runtime_conditions"
      priority_scheduling: "prioritize_high_impact_workflow_steps"
      load_balancing: "balance_load_across_available_agent_resources"

# =============================================================================
# MONITORING AND ANALYTICS
# =============================================================================

monitoring_framework:
  
  real_time_monitoring:
    workflow_progress_tracking:
      step_completion_monitoring: "track_completion_of_individual_workflow_steps"
      milestone_achievement_tracking: "monitor_achievement_of_workflow_milestones"
      overall_progress_calculation: "calculate_overall_workflow_progress_percentage"
      
    performance_monitoring:
      execution_time_tracking: "measure_execution_time_for_each_workflow_step"
      resource_utilization_monitoring: "track_resource_usage_throughout_workflow"
      throughput_measurement: "measure_workflow_processing_throughput"
      
    quality_monitoring:
      quality_metrics_tracking: "monitor_quality_scores_at_each_workflow_step"
      quality_trend_analysis: "analyze_quality_trends_over_time"
      quality_degradation_detection: "detect_quality_degradation_early"
      
  analytics_and_insights:
    workflow_performance_analysis:
      bottleneck_analysis: "identify_consistent_performance_bottlenecks"
      efficiency_analysis: "analyze_workflow_efficiency_and_waste"
      optimization_opportunity_identification: "identify_optimization_opportunities"
      
    quality_analytics:
      quality_correlation_analysis: "correlate_quality_with_workflow_characteristics"
      quality_prediction_modeling: "predict_quality_outcomes_based_on_inputs"
      quality_improvement_tracking: "track_effectiveness_of_quality_improvements"
      
    success_pattern_recognition:
      successful_workflow_pattern_identification: "identify_patterns_in_successful_workflows"
      failure_pattern_analysis: "analyze_common_patterns_in_failed_workflows"
      best_practice_extraction: "extract_best_practices_from_successful_workflows"

# =============================================================================
# INTEGRATION EXAMPLES
# =============================================================================

integration_examples:
  
  complete_consultation_workflow:
    description: "End-to-end consultation session workflow"
    total_duration: "30-60 minutes"
    phases: ["research", "consultation", "generation", "validation"]
    
    sequential_coordination:
      research_phase:
        duration: "8-12 minutes"
        agents: ["research_validator", "pattern_detective"]
        handoff_to: "consultation_phase"
        
      consultation_phase:
        duration: "15-20 minutes"
        agents: ["domain_expert", "architecture_agent", "user_interaction_coordinator"]
        handoff_to: "generation_phase"
        
      generation_phase:
        duration: "10-15 minutes"
        agents: ["context_engineer", "command_builder", "documentation_agent"]
        handoff_to: "validation_phase"
        
      validation_phase:
        duration: "5-10 minutes"
        agents: ["quality_guardian", "integration_validator"]
        final_deliverable: "complete_claude_context_setup"
        
  tdd_enforcement_workflow:
    description: "Strict TDD enforcement with code deletion penalty"
    enforced_sequence:
      1:
        agent: "testing_agent"
        task: "write_failing_tests"
        validation: "tests_confirmed_failing"
        violation_penalty: "workflow_termination"
        
      2:
        agent: "code_generation_agent"
        task: "minimal_implementation_to_pass_tests"
        validation: "tests_now_pass_implementation_minimal"
        violation_penalty: "implementation_deletion_restart_from_step_1"
        
      3:
        agent: "refactoring_agent"
        task: "improve_implementation_while_keeping_tests_passing"
        validation: "tests_still_pass_after_refactoring"
        violation_penalty: "revert_refactoring_changes"

# =============================================================================
# END OF SEQUENTIAL WORKFLOW ORCHESTRATION
# =============================================================================